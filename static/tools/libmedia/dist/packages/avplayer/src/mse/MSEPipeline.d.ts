import { type AVPacketPool, type AVPacketRef, AVCodecParameters, type AVRational, type AVCodecParametersSerialize } from '@libmedia/avutil';
import { type Mutex, type List } from '@libmedia/cheap';
import { type Data } from '@libmedia/common';
import { IOWriterSync as IOWriter, SeekableWriteBuffer } from '@libmedia/common/io';
import { LoopTask, WorkerTimer } from '@libmedia/common/timer';
import { IPCPort } from '@libmedia/common/network';
import { type AVOFormatContext, type OFormat } from '@libmedia/avformat';
import { Track } from '@libmedia/avrender';
import { type TaskOptions, Pipeline } from '@libmedia/avpipeline';
export interface MSETaskOptions extends TaskOptions {
    isLive: boolean;
    avpacketList: pointer<List<pointer<AVPacketRef>>>;
    avpacketListMutex: pointer<Mutex>;
    enableJitterBuffer: boolean;
}
interface PullQueue {
    queue: pointer<AVPacketRef>[];
    index: int32;
    frameCount: int64;
    lastPTS: int64;
    lastDTS: int64;
    diff: int64;
    ended: boolean;
    useSampleRateTimeBase: boolean;
}
interface MSEResource {
    type: 'audio' | 'video';
    codecpar: pointer<AVCodecParameters>;
    oformatContext: AVOFormatContext;
    oformat: OFormat;
    ioWriter: IOWriter;
    bufferQueue: SeekableWriteBuffer;
    track: Track;
    streamIndex: int32;
    pullIPC: IPCPort;
    loop: LoopTask;
    startTimestamp: int64;
    frontPacket: pointer<AVPacketRef>;
    backPacket: pointer<AVPacketRef>;
    frontBuffered: boolean;
    packetEnded: boolean;
    ended: boolean;
    seekSync: () => void;
    startPTS: int64;
    lastDTS: int64;
    pullQueue: PullQueue;
    enableRawMpeg: boolean;
    timestampOffsetUpdated: boolean;
    ignoreEncryption: boolean;
}
type SelfTask = MSETaskOptions & {
    mediaSource: MediaSource;
    controlIPCPort: IPCPort;
    audio: MSEResource;
    video: MSEResource;
    pauseTimestamp: number;
    playRate: int64;
    targetRate: int64;
    seeking: boolean;
    pausing: boolean;
    cacheDuration: int64;
    currentTime: double;
    currentTimeNTP: int32;
    avpacketPool: AVPacketPool;
    maxBuffer: float;
    minBuffer: float;
    visibilityHidden: boolean;
    fakePlayTimer: WorkerTimer;
};
export default class MSEPipeline extends Pipeline {
    tasks: Map<string, SelfTask>;
    constructor();
    private syncToKeyframe;
    private getSourceOpenHandler;
    private getMimeType;
    private createSourceBuffer;
    private mixExtradata;
    private checkEnableEncryption;
    private pullAVPacketInternal;
    private pullAVPacket;
    private writeAVPacket;
    private swap;
    private createLoop;
    private startMux;
    private resetResource;
    addStream(taskId: string, streamIndex: int32, parameters: pointer<AVCodecParameters> | AVCodecParametersSerialize, timeBase: AVRational, metadata: Data, startPTS: int64, pullIPCPort: MessagePort): Promise<void>;
    reAddStream(taskId: string, streamIndex: int32, parameters: pointer<AVCodecParameters> | AVCodecParametersSerialize, timeBase: AVRational, metadata: Data, startPTS: int64): Promise<void>;
    pause(taskId: string): Promise<void>;
    unpause(taskId: string): Promise<void>;
    beforeSeek(taskId: string): Promise<void>;
    afterSeek(taskId: string, timestamp: int64): Promise<number>;
    setPlayRate(taskId: string, rate: double): Promise<void>;
    restart(taskId: string): Promise<void>;
    setCurrentTime(taskId: string, time: number): Promise<void>;
    private checkWaiting;
    getMediaSource(taskId: string): Promise<MediaSource>;
    isManagedMediaSource(taskId: string): Promise<boolean>;
    private createTask;
    setVisibilityHidden(taskId: string, visibilityHidden: boolean): Promise<void>;
    registerTask(options: MSETaskOptions, startTimestamp?: int64): Promise<number>;
    unregisterTask(id: string): Promise<void>;
}
export {};
