import { IPCPort } from '@libmedia/common/network';
import { type AVFrameRef, AVFramePoolImpl, type AVPCMBuffer, type AVPCMBufferRef, type AVSampleFormat } from '@libmedia/avutil';
import { type WebAssemblyResource, type Mutex, type List } from '@libmedia/cheap';
import { WorkerSetTimeout, MasterTimer } from '@libmedia/common/timer';
import { Resampler } from '@libmedia/audioresample';
import { StretchPitcher } from '@libmedia/audiostretchpitch';
import type { TaskOptions } from './Pipeline';
import Pipeline from './Pipeline';
import type { Timeout } from '@libmedia/common';
export interface AudioRenderTaskOptions extends TaskOptions {
    playSampleRate: int32;
    playFormat: AVSampleFormat;
    playChannels: int32;
    resamplerResource: ArrayBuffer | WebAssemblyResource;
    stretchpitcherResource: ArrayBuffer | WebAssemblyResource;
    startPTS: int64;
    avframeList: pointer<List<pointer<AVFrameRef>>>;
    avframeListMutex: pointer<Mutex>;
    enableJitterBuffer: boolean;
    isLive: boolean;
    audioMasterForce: boolean;
}
type SelfTask = AudioRenderTaskOptions & {
    leftIPCPort: IPCPort;
    rightIPCPort: IPCPort;
    controlIPCPort: IPCPort;
    resamplerResource: WebAssemblyResource;
    stretchpitcherResource: WebAssemblyResource;
    resampler: Resampler;
    stretchpitcher: Map<int32, StretchPitcher>;
    outPCMBuffer: AVPCMBuffer;
    waitPCMBuffer: pointer<AVPCMBufferRef>;
    waitPCMBufferPos: int32;
    waitAVFrame: pointer<AVFrameRef>;
    ended: boolean;
    stretchpitcherEnded: boolean;
    playRate: double;
    playTempo: double;
    playPitch: double;
    useStretchpitcher: boolean;
    firstPlayed: boolean;
    lastNotifyPTS: int64;
    currentPTS: int64;
    lastMasterPts: int64;
    masterTimer: MasterTimer;
    seeking: boolean;
    pausing: boolean;
    stopping: boolean;
    seekSync: () => void;
    receivePCMSync: () => void;
    paddingAVFrame: pointer<AVFrameRef>;
    fakePlayStartTimestamp: number;
    fakePlaySamples: int64;
    fakePlayTimer: Timeout;
    fakePlayWorkerTimer: WorkerSetTimeout;
    fakePlay: boolean;
    lastRenderTimestamp: number;
    avframePool: AVFramePoolImpl;
};
export default class AudioRenderPipeline extends Pipeline {
    tasks: Map<string, SelfTask>;
    private avPCMBufferPool;
    private avPCMBufferList;
    private avPCMBufferListMutex;
    constructor();
    private createTask;
    private checkUseStretchpitcher;
    setPlayRate(taskId: string, rate: double): void;
    setPlayTempo(taskId: string, tempo: double): Promise<void>;
    setPlayPitch(taskId: string, pitch: double): void;
    beforeSeek(taskId: string): Promise<void>;
    syncSeekTime(taskId: string, timestamp: int64, maxQueueLength?: number): Promise<void>;
    isEnd(taskId: string): Promise<boolean>;
    afterSeek(taskId: string, timestamp: int64): Promise<void>;
    restart(taskId: string): Promise<void>;
    setMasterTime(taskId: string, masterTime: int64): Promise<void>;
    private fakeSyncPts;
    private syncPts;
    private clearFakePlayTimer;
    private setFakePlayTimer;
    private fakePlayNext;
    fakePlay(taskId: string): Promise<void>;
    pause(taskId: string): Promise<void>;
    unpause(taskId: string): Promise<void>;
    stop(taskId: string): Promise<void>;
    registerTask(options: AudioRenderTaskOptions): Promise<number>;
    unregisterTask(taskId: string): Promise<void>;
    clear(): Promise<void>;
}
export {};
